name: Version Manager
# 
# Versioning Strategy:
# - MAJOR.RELEASE.PATCH format (e.g., 1.2.3)
# - MAJOR: Major version, manually incremented for breaking changes
# - RELEASE: Incremented on each production deployment
# - PATCH: Incremented on each merge to main (staging deployment), reset to 0 on production release
#
# Example flow:
# - Main branch merges: 1.0.1, 1.0.2, 1.0.3 (staging)
# - Production release: 1.1.0 (RELEASE incremented, PATCH reset)
# - Next main merges: 1.1.1, 1.1.2 (staging)
# - Next production: 1.2.0

on:
  workflow_call:
    outputs:
      version:
        description: 'The calculated version'
        value: ${{ jobs.manage-version.outputs.version }}
      image-tag:
        description: 'The Docker image tag'
        value: ${{ jobs.manage-version.outputs.image-tag }}
    inputs:
      custom-version:
        description: 'Custom version override'
        required: false
        type: string

jobs:
  manage-version:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      image-tag: ${{ steps.version.outputs.image-tag }}
    steps:
      - name: Checkout versions branch
        uses: actions/checkout@v4
        with:
          ref: versions
          fetch-depth: 1
          token: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Checkout main for commit history
        run: |
          git fetch origin main --depth=50
          
      - name: Calculate version
        id: version
        run: |
          # Read version components from versions branch
          MAJOR=$(cat VERSION_MAJOR 2>/dev/null || echo "1")
          RELEASE=$(cat VERSION_RELEASE 2>/dev/null || echo "0")
          
          # If custom version provided, use it
          if [ -n "${{ inputs.custom-version }}" ]; then
            VERSION="${{ inputs.custom-version }}"
            
            # Extract components from custom version
            IFS='.' read -r CUSTOM_MAJOR CUSTOM_RELEASE CUSTOM_PATCH <<< "$VERSION"
            
            # Update version files if components differ
            if [ "$CUSTOM_MAJOR" != "$MAJOR" ] || [ "$CUSTOM_RELEASE" != "$RELEASE" ]; then
              echo "⚠️ Custom version override: updating version components"
              echo "$CUSTOM_MAJOR" > VERSION_MAJOR
              echo "$CUSTOM_RELEASE" > VERSION_RELEASE
              echo "${CUSTOM_PATCH:-0}" > VERSION_PR
            fi
            
            echo "version=${VERSION}" >> $GITHUB_OUTPUT
            echo "image-tag=${VERSION}-staging" >> $GITHUB_OUTPUT
          else
            # For staging deployments, increment the patch version (third number)
            # This represents the number of merges to main since the last production release
            LAST_PATCH=$(cat VERSION_PR 2>/dev/null || echo "0")
            PATCH=$((LAST_PATCH + 1))
            
            # Save the new patch number
            echo "$PATCH" > VERSION_PR
            
            # Create version string
            VERSION="${MAJOR}.${RELEASE}.${PATCH}"
            
            echo "version=${VERSION}" >> $GITHUB_OUTPUT
            echo "image-tag=${VERSION}-staging" >> $GITHUB_OUTPUT
          fi
          
          echo "📦 Version: ${VERSION}"
          echo "📦 Components: Major=${MAJOR}, Release=${RELEASE}, Patch=${PATCH:-custom}"
          
      - name: Update version files on versions branch
        run: |
          echo "${{ steps.version.outputs.version }}" > VERSION
          
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          
          # Add all version files (they may have been updated by custom version logic)
          git add VERSION VERSION_MAJOR VERSION_RELEASE VERSION_PR 2>/dev/null || true
          git diff --staged --quiet || {
            git commit -m "chore: update version to ${{ steps.version.outputs.version }}"
            git push origin versions || git push origin versions --force-with-lease
          }