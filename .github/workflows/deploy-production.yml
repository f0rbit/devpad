name: Deploy Production

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to deploy (leave empty to use latest staging)'
        required: false
        type: string
      skip_promotion:
        description: 'Skip staging promotion (use existing production image)'
        required: false
        type: boolean
        default: false

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

concurrency:
  group: production-deployment
  cancel-in-progress: false

jobs:
  calculate-version:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      prev_version: ${{ steps.version.outputs.prev_version }}
    steps:
      - name: Checkout versions branch
        uses: actions/checkout@v4
        with:
          ref: versions
          fetch-depth: 1
          token: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Calculate production version
        id: version
        run: |
          # Read version components from versions branch
          MAJOR=$(cat VERSION_MAJOR 2>/dev/null || echo "1")
          PREV_RELEASE=$(cat VERSION_RELEASE 2>/dev/null || echo "0")
          
          # Calculate new release number
          if [ "${{ github.event.inputs.skip_promotion }}" = "true" ]; then
            # Use existing release number
            RELEASE=$PREV_RELEASE
          else
            # Increment release number
            RELEASE=$((PREV_RELEASE + 1))
          fi
          
          # Determine version
          if [ -n "${{ github.event.inputs.version }}" ]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION="${MAJOR}.${RELEASE}.0"
          fi
          
          PREV_VERSION="${MAJOR}.${PREV_RELEASE}.0"
          
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "prev_version=${PREV_VERSION}" >> $GITHUB_OUTPUT
          echo "release=${RELEASE}" >> $GITHUB_OUTPUT
          echo "ðŸ“¦ New Version: ${VERSION}"
          echo "ðŸ“¦ Previous Version: ${PREV_VERSION}"
          
      - name: Update version files on versions branch
        if: github.event.inputs.skip_promotion != 'true'
        run: |
          echo "${{ steps.version.outputs.version }}" > VERSION
          echo "${{ steps.version.outputs.release }}" > VERSION_RELEASE
          echo "0" > VERSION_PR  # Reset PR counter for new release
          
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git add VERSION VERSION_RELEASE VERSION_PR
          git commit -m "chore: bump production version to ${{ steps.version.outputs.version }}"
          git push origin versions

  promote-staging-to-production:
    runs-on: ubuntu-latest
    needs: calculate-version
    if: github.event.inputs.skip_promotion != 'true'
    permissions:
      contents: read
      packages: write
    steps:
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Promote staging image to production
        run: |
          # Pull the current staging image
          docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:staging
          
          # Tag it with production tags
          docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:staging \
                     ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
          docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:staging \
                     ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:stable
          docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:staging \
                     ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.calculate-version.outputs.version }}
          
          # Push all tags
          docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
          docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:stable
          docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.calculate-version.outputs.version }}
          
          echo "âœ… Promoted staging to production version ${{ needs.calculate-version.outputs.version }}"

  deploy-to-production:
    runs-on: ubuntu-latest
    needs: [calculate-version, promote-staging-to-production]
    if: always() && (needs.promote-staging-to-production.result == 'success' || needs.promote-staging-to-production.result == 'skipped')
    environment:
      name: production
      url: https://devpad.tools
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Deploy to production VPS
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          port: ${{ secrets.SSH_PORT }}
          key: ${{ secrets.SSH_KEY }}
          script: |
            # Navigate to deployment directory
            cd /var/deploy/devpad
            
            # Save new version
            echo "${{ needs.calculate-version.outputs.version }}" > VERSION
            export VERSION=${{ needs.calculate-version.outputs.version }}
            
            # Tag current running image as previous before updating
            docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:production-previous || true
            
            # Pull latest image
            docker-compose -f docker-compose.production.yml pull
            
            # Stop and remove old container
            docker-compose -f docker-compose.production.yml down
            
            # Start new container
            docker-compose -f docker-compose.production.yml up -d
            
            # Wait for health check
            echo "Waiting for container to be healthy..."
            for i in {1..30}; do
                if docker-compose -f docker-compose.production.yml exec -T devpad-production curl -f http://localhost:3000/health 2>/dev/null; then
                    echo "âœ… Health check passed!"
                    break
                elif [ $i -eq 30 ]; then
                    echo "âŒ Health check failed after 30 attempts"
                    docker-compose -f docker-compose.production.yml logs --tail 50
                    exit 1
                else
                    echo "Attempt $i/30: Waiting for service to be ready..."
                    sleep 2
                fi
            done
            
            # Clean up old images (keep last 5)
            docker image prune -f
            docker images | grep devpad | tail -n +6 | awk '{print $3}' | xargs -r docker rmi || true
            
            echo "âœ… Production deployment successful!"
            
      - name: Run smoke tests
        run: |
          # Wait for service to be ready
          sleep 15
          
          # Test health endpoint
          curl -f https://devpad.tools/health || exit 1
          
          # Test API endpoint
          curl -f https://devpad.tools/api/v0 || exit 1
          
          echo "âœ… Production smoke tests passed!"
          
      - name: Create deployment summary
        run: |
          echo "## ðŸŽ‰ Production Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** \`${{ needs.calculate-version.outputs.version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Previous Version:** \`${{ needs.calculate-version.outputs.prev_version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** Production" >> $GITHUB_STEP_SUMMARY
          echo "**URL:** https://devpad.tools" >> $GITHUB_STEP_SUMMARY
          echo "**Image:** \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.calculate-version.outputs.version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ github.event_name }}" = "release" ]; then
            echo "### Release Info" >> $GITHUB_STEP_SUMMARY
            echo "**Release Name:** ${{ github.event.release.name }}" >> $GITHUB_STEP_SUMMARY
            echo "**Release Tag:** ${{ github.event.release.tag_name }}" >> $GITHUB_STEP_SUMMARY
            echo "**Author:** ${{ github.event.release.author.login }}" >> $GITHUB_STEP_SUMMARY
          fi
          
  rollback-on-failure:
    runs-on: ubuntu-latest
    needs: [calculate-version, deploy-to-production]
    if: failure()
    steps:
      - name: Rollback production deployment
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          port: ${{ secrets.SSH_PORT }}
          key: ${{ secrets.SSH_KEY }}
          script: |
            cd /var/deploy/devpad
            
            echo "âš ï¸ Rolling back to version ${{ needs.calculate-version.outputs.prev_version }}"
            
            # Restore previous version
            echo "${{ needs.calculate-version.outputs.prev_version }}" > VERSION
            export VERSION=${{ needs.calculate-version.outputs.prev_version }}
            
            # Use the previous image
            docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:production-previous ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
            
            # Stop current container
            docker-compose -f docker-compose.production.yml down
            
            # Start with previous version
            docker-compose -f docker-compose.production.yml up -d
            
            # Wait for health check
            echo "Waiting for rollback container to be healthy..."
            for i in {1..30}; do
                if docker-compose -f docker-compose.production.yml exec -T devpad-production curl -f http://localhost:3000/health 2>/dev/null; then
                    echo "âœ… Rollback health check passed!"
                    break
                elif [ $i -eq 30 ]; then
                    echo "âŒ Rollback health check failed!"
                    docker-compose -f docker-compose.production.yml logs --tail 50
                    exit 1
                else
                    echo "Attempt $i/30: Waiting for rollback to be ready..."
                    sleep 2
                fi
            done
            
            # Tag the failed version for investigation
            docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.calculate-version.outputs.version }} \
                      ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:failed-${{ needs.calculate-version.outputs.version }}
            
            echo "âœ… Rollback to ${{ needs.calculate-version.outputs.prev_version }} completed"
            
      - name: Notify rollback
        run: |
          echo "## âš ï¸ Production Deployment Rolled Back" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Failed Version:** \`${{ needs.calculate-version.outputs.version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Rolled Back To:** \`${{ needs.calculate-version.outputs.prev_version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Please investigate the failure before attempting another deployment." >> $GITHUB_STEP_SUMMARY