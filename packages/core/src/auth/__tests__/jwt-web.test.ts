import { describe, expect, test } from "bun:test";
import { decodeJWT, generateJWT, verifyJWT } from "../jwt-web.js";

const TEST_SECRET = "test-secret-key-for-jwt-testing";

describe("generateJWT", () => {
	test("produces a valid JWT string with 3 dot-separated parts", async () => {
		const result = await generateJWT(TEST_SECRET, {
			user_id: "user_123",
			session_id: "session_456",
		});

		expect(result.ok).toBe(true);
		if (!result.ok) return;

		const parts = result.value.split(".");
		expect(parts.length).toBe(3);
		expect(parts.every(p => p.length > 0)).toBe(true);
	});

	test("includes iat and exp in payload", async () => {
		const result = await generateJWT(TEST_SECRET, {
			user_id: "user_123",
			session_id: "session_456",
		});

		expect(result.ok).toBe(true);
		if (!result.ok) return;

		const decoded = decodeJWT(result.value);
		expect(decoded.ok).toBe(true);
		if (!decoded.ok) return;

		expect(decoded.value.iat).toBeGreaterThan(0);
		expect(decoded.value.exp).toBeGreaterThan(decoded.value.iat);
		expect(decoded.value.exp - decoded.value.iat).toBe(24 * 60 * 60);
	});
});

describe("verifyJWT", () => {
	test("successfully verifies a token generated by generateJWT", async () => {
		const gen_result = await generateJWT(TEST_SECRET, {
			user_id: "user_abc",
			session_id: "session_def",
		});
		expect(gen_result.ok).toBe(true);
		if (!gen_result.ok) return;

		const verify_result = await verifyJWT(TEST_SECRET, gen_result.value);
		expect(verify_result.ok).toBe(true);
		if (!verify_result.ok) return;

		expect(verify_result.value.user_id).toBe("user_abc");
		expect(verify_result.value.session_id).toBe("session_def");
	});

	test("rejects tokens with wrong secret", async () => {
		const gen_result = await generateJWT(TEST_SECRET, {
			user_id: "user_123",
			session_id: "session_456",
		});
		expect(gen_result.ok).toBe(true);
		if (!gen_result.ok) return;

		const verify_result = await verifyJWT("wrong-secret", gen_result.value);
		expect(verify_result.ok).toBe(false);
		if (verify_result.ok) return;

		expect(verify_result.error.kind).toBe("invalid_signature");
	});

	test("rejects malformed tokens", async () => {
		const result = await verifyJWT(TEST_SECRET, "not.a.valid.jwt");
		expect(result.ok).toBe(false);
		if (result.ok) return;
		expect(result.error.kind).toBe("malformed");
	});

	test("rejects token with only two parts", async () => {
		const result = await verifyJWT(TEST_SECRET, "header.payload");
		expect(result.ok).toBe(false);
		if (result.ok) return;
		expect(result.error.kind).toBe("malformed");
	});

	test("rejects expired tokens", async () => {
		const gen_result = await generateJWT(TEST_SECRET, {
			user_id: "user_123",
			session_id: "session_456",
		});
		expect(gen_result.ok).toBe(true);
		if (!gen_result.ok) return;

		const parts = gen_result.value.split(".");
		const payload_json = JSON.parse(atob(parts[1].replace(/-/g, "+").replace(/_/g, "/")));
		payload_json.exp = Math.floor(Date.now() / 1000) - 3600;

		const tampered_payload = btoa(JSON.stringify(payload_json)).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");

		const tampered_token = `${parts[0]}.${tampered_payload}.${parts[2]}`;

		const verify_result = await verifyJWT(TEST_SECRET, tampered_token);
		expect(verify_result.ok).toBe(false);
		if (verify_result.ok) return;

		const valid_errors = ["invalid_signature", "expired"];
		expect(valid_errors).toContain(verify_result.error.kind);
	});
});

describe("decodeJWT", () => {
	test("decodes without verification", async () => {
		const gen_result = await generateJWT(TEST_SECRET, {
			user_id: "user_decode",
			session_id: "session_decode",
		});
		expect(gen_result.ok).toBe(true);
		if (!gen_result.ok) return;

		const decoded = decodeJWT(gen_result.value);
		expect(decoded.ok).toBe(true);
		if (!decoded.ok) return;

		expect(decoded.value.user_id).toBe("user_decode");
		expect(decoded.value.session_id).toBe("session_decode");
	});

	test("rejects completely invalid tokens", () => {
		const result = decodeJWT("garbage");
		expect(result.ok).toBe(false);
	});
});

describe("round-trip", () => {
	test("generate → verify → payload matches", async () => {
		const payload = { user_id: "user_rt", session_id: "session_rt" };
		const gen = await generateJWT(TEST_SECRET, payload);
		expect(gen.ok).toBe(true);
		if (!gen.ok) return;

		const verified = await verifyJWT(TEST_SECRET, gen.value);
		expect(verified.ok).toBe(true);
		if (!verified.ok) return;

		expect(verified.value.user_id).toBe(payload.user_id);
		expect(verified.value.session_id).toBe(payload.session_id);
		expect(typeof verified.value.iat).toBe("number");
		expect(typeof verified.value.exp).toBe("number");
	});
});
